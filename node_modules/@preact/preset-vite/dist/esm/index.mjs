import prefresh from "@prefresh/vite";
import { preactDevtoolsPlugin } from "./devtools.mjs";
import { createFilter, parseId } from "./utils.mjs";
import { PrerenderPlugin, HTMLRoutingMiddlewarePlugin } from "./prerender.mjs";
import { transformAsync } from "@babel/core";
// Taken from https://github.com/vitejs/vite/blob/main/packages/plugin-react/src/index.ts
function preactPlugin({ devtoolsInProd, devToolsEnabled, prefreshEnabled, reactAliasesEnabled, prerender, include, exclude, babel, jsxImportSource, } = {}) {
    var _a;
    const baseParserOptions = [
        "importMeta",
        "explicitResourceManagement",
        "topLevelAwait",
    ];
    let config;
    let babelOptions = {
        babelrc: false,
        configFile: false,
        ...babel,
    };
    babelOptions.plugins || (babelOptions.plugins = []);
    babelOptions.presets || (babelOptions.presets = []);
    babelOptions.overrides || (babelOptions.overrides = []);
    babelOptions.parserOpts || (babelOptions.parserOpts = {});
    (_a = babelOptions.parserOpts).plugins || (_a.plugins = []);
    let useBabel;
    const shouldTransform = createFilter(include || [/\.[cm]?[tj]sx?$/], exclude || [/node_modules/]);
    devtoolsInProd = devtoolsInProd !== null && devtoolsInProd !== void 0 ? devtoolsInProd : false;
    prefreshEnabled = prefreshEnabled !== null && prefreshEnabled !== void 0 ? prefreshEnabled : true;
    reactAliasesEnabled = reactAliasesEnabled !== null && reactAliasesEnabled !== void 0 ? reactAliasesEnabled : true;
    prerender = prerender !== null && prerender !== void 0 ? prerender : { enabled: false };
    const jsxPlugin = {
        name: "vite:preact-jsx",
        enforce: "pre",
        config() {
            return {
                build: {
                    rollupOptions: {
                        onwarn(warning, warn) {
                            // Silence Rollup's module-level directive warnings -- they're likely
                            // to all come from `node_modules` (RSCs) and won't be actionable.
                            if (warning.code === "MODULE_LEVEL_DIRECTIVE")
                                return;
                            warn(warning);
                        },
                    },
                },
                // While this config is unconditional, it'll only be used if Babel is not
                esbuild: {
                    jsx: "automatic",
                    jsxImportSource: jsxImportSource !== null && jsxImportSource !== void 0 ? jsxImportSource : "preact",
                },
                optimizeDeps: {
                    include: ["preact/jsx-runtime", "preact/jsx-dev-runtime"],
                },
            };
        },
        configResolved(resolvedConfig) {
            config = resolvedConfig;
            devToolsEnabled =
                devToolsEnabled !== null && devToolsEnabled !== void 0 ? devToolsEnabled : (!config.isProduction || devtoolsInProd);
            useBabel =
                !config.isProduction || devToolsEnabled || typeof babel !== "undefined";
        },
        async transform(code, url) {
            // Ignore query parameters, as in Vue SFC virtual modules.
            const { id } = parseId(url);
            if (!useBabel || !shouldTransform(id))
                return;
            const parserPlugins = [
                ...baseParserOptions,
                "classProperties",
                "classPrivateProperties",
                "classPrivateMethods",
                !id.endsWith(".ts") && "jsx",
                /\.tsx?$/.test(id) && "typescript",
            ].filter(Boolean);
            const result = await transformAsync(code, {
                ...babelOptions,
                ast: true,
                root: config.root,
                filename: id,
                parserOpts: {
                    ...babelOptions.parserOpts,
                    sourceType: "module",
                    allowAwaitOutsideFunction: true,
                    plugins: parserPlugins,
                },
                generatorOpts: {
                    ...babelOptions.generatorOpts,
                    decoratorsBeforeExport: true,
                },
                plugins: [
                    ...babelOptions.plugins,
                    [
                        config.isProduction
                            ? "@babel/plugin-transform-react-jsx"
                            : "@babel/plugin-transform-react-jsx-development",
                        {
                            runtime: "automatic",
                            importSource: jsxImportSource !== null && jsxImportSource !== void 0 ? jsxImportSource : "preact",
                        },
                    ],
                    ...(devToolsEnabled ? ["babel-plugin-transform-hook-names"] : []),
                ],
                sourceMaps: true,
                inputSourceMap: false,
            });
            // NOTE: Since no config file is being loaded, this path wouldn't occur.
            if (!result)
                return;
            return {
                code: result.code || code,
                map: result.map,
            };
        },
    };
    return [
        ...(reactAliasesEnabled
            ? [
                {
                    name: "preact:config",
                    config() {
                        return {
                            resolve: {
                                alias: {
                                    "react-dom/test-utils": "preact/test-utils",
                                    "react-dom": "preact/compat",
                                    react: "preact/compat",
                                },
                            },
                        };
                    },
                },
            ]
            : []),
        jsxPlugin,
        preactDevtoolsPlugin({
            devtoolsInProd,
            devToolsEnabled,
            shouldTransform,
        }),
        ...(prefreshEnabled
            ? [prefresh({ include, exclude, parserPlugins: baseParserOptions })]
            : []),
        ...(prerender.enabled ? [PrerenderPlugin(prerender)] : []),
        ...(prerender.previewMiddlewareEnabled
            ? [
                HTMLRoutingMiddlewarePlugin({
                    fallback: prerender.previewMiddlewareFallback,
                }),
            ]
            : []),
    ];
}
export default preactPlugin;
export { preactPlugin as preact };

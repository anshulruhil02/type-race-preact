import "./chunk-J64Z4577.js";
import {
  b,
  k,
  l
} from "./chunk-LZPYHAPA.js";

// node_modules/preact/debug/dist/debug.module.js
var o = {};
function r() {
  o = {};
}
function a(e) {
  return e.type === k ? "Fragment" : "function" == typeof e.type ? e.type.displayName || e.type.name : "string" == typeof e.type ? e.type : "#text";
}
var i = [];
var s = [];
function c() {
  return i.length > 0 ? i[i.length - 1] : null;
}
var l2 = true;
function u(e) {
  return "function" == typeof e.type && e.type != k;
}
function f(n) {
  for (var e = [n], t = n; null != t.__o; ) e.push(t.__o), t = t.__o;
  return e.reduce(function(n2, e2) {
    n2 += "  in " + a(e2);
    var t2 = e2.__source;
    return t2 ? n2 += " (at " + t2.fileName + ":" + t2.lineNumber + ")" : l2 && console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons."), l2 = false, n2 + "\n";
  }, "");
}
var p = "function" == typeof WeakMap;
function d(n) {
  var e = [];
  return n.__k ? (n.__k.forEach(function(n2) {
    n2 && "function" == typeof n2.type ? e.push.apply(e, d(n2)) : n2 && "string" == typeof n2.type && e.push(n2.type);
  }), e) : e;
}
function h(n) {
  return n ? "function" == typeof n.type ? null === n.__ ? null !== n.__e && null !== n.__e.parentNode ? n.__e.parentNode.localName : "" : h(n.__) : n.type : "";
}
var v = b.prototype.setState;
function y(n) {
  return "table" === n || "tfoot" === n || "tbody" === n || "thead" === n || "td" === n || "tr" === n || "th" === n;
}
b.prototype.setState = function(n, e) {
  return null == this.__v && null == this.state && console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n' + f(c())), v.call(this, n, e);
};
var m = /^(address|article|aside|blockquote|details|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|main|menu|nav|ol|p|pre|search|section|table|ul)$/;
var b2 = b.prototype.forceUpdate;
function w(n) {
  var e = n.props, t = a(n), o2 = "";
  for (var r2 in e) if (e.hasOwnProperty(r2) && "children" !== r2) {
    var i2 = e[r2];
    "function" == typeof i2 && (i2 = "function " + (i2.displayName || i2.name) + "() {}"), i2 = Object(i2) !== i2 || i2.toString ? i2 + "" : Object.prototype.toString.call(i2), o2 += " " + r2 + "=" + JSON.stringify(i2);
  }
  var s2 = e.children;
  return "<" + t + o2 + (s2 && s2.length ? ">..</" + t + ">" : " />");
}
b.prototype.forceUpdate = function(n) {
  return null == this.__v ? console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n' + f(c())) : null == this.__P && console.warn(`Can't call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.

` + f(this.__v)), b2.call(this, n);
}, function() {
  !function() {
    var n2 = l.__b, t2 = l.diffed, o2 = l.__, r3 = l.vnode, a2 = l.__r;
    l.diffed = function(n3) {
      u(n3) && s.pop(), i.pop(), t2 && t2(n3);
    }, l.__b = function(e) {
      u(e) && i.push(e), n2 && n2(e);
    }, l.__ = function(n3, e) {
      s = [], o2 && o2(n3, e);
    }, l.vnode = function(n3) {
      n3.__o = s.length > 0 ? s[s.length - 1] : null, r3 && r3(n3);
    }, l.__r = function(n3) {
      u(n3) && s.push(n3), a2 && a2(n3);
    };
  }();
  var n = false, t = l.__b, r2 = l.diffed, c2 = l.vnode, l3 = l.__r, v2 = l.__e, b3 = l.__, g = l.__h, E = p ? { useEffect: /* @__PURE__ */ new WeakMap(), useLayoutEffect: /* @__PURE__ */ new WeakMap(), lazyPropTypes: /* @__PURE__ */ new WeakMap() } : null, k2 = [];
  l.__e = function(n2, e, t2, o2) {
    if (e && e.__c && "function" == typeof n2.then) {
      var r3 = n2;
      n2 = new Error("Missing Suspense. The throwing component was: " + a(e));
      for (var i2 = e; i2; i2 = i2.__) if (i2.__c && i2.__c.__c) {
        n2 = r3;
        break;
      }
      if (n2 instanceof Error) throw n2;
    }
    try {
      (o2 = o2 || {}).componentStack = f(e), v2(n2, e, t2, o2), "function" != typeof n2.then && setTimeout(function() {
        throw n2;
      });
    } catch (n3) {
      throw n3;
    }
  }, l.__ = function(n2, e) {
    if (!e) throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");
    var t2;
    switch (e.nodeType) {
      case 1:
      case 11:
      case 9:
        t2 = true;
        break;
      default:
        t2 = false;
    }
    if (!t2) {
      var o2 = a(n2);
      throw new Error("Expected a valid HTML node as a second argument to render.	Received " + e + " instead: render(<" + o2 + " />, " + e + ");");
    }
    b3 && b3(n2, e);
  }, l.__b = function(e) {
    var r3 = e.type;
    if (n = true, void 0 === r3) throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports" + w(e) + "\n\n" + f(e));
    if (null != r3 && "object" == typeof r3) {
      if (void 0 !== r3.__k && void 0 !== r3.__e) throw new Error("Invalid type passed to createElement(): " + r3 + "\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My" + a(e) + " = " + w(r3) + ";\n  let vnode = <My" + a(e) + " />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n" + f(e));
      throw new Error("Invalid type passed to createElement(): " + (Array.isArray(r3) ? "array" : r3));
    }
    if (void 0 !== e.ref && "function" != typeof e.ref && "object" != typeof e.ref && !("$$typeof" in e)) throw new Error(`Component's "ref" property should be a function, or an object created by createRef(), but got [` + typeof e.ref + "] instead\n" + w(e) + "\n\n" + f(e));
    if ("string" == typeof e.type) {
      for (var i2 in e.props) if ("o" === i2[0] && "n" === i2[1] && "function" != typeof e.props[i2] && null != e.props[i2]) throw new Error(`Component's "` + i2 + '" property should be a function, but got [' + typeof e.props[i2] + "] instead\n" + w(e) + "\n\n" + f(e));
    }
    if ("function" == typeof e.type && e.type.propTypes) {
      if ("Lazy" === e.type.displayName && E && !E.lazyPropTypes.has(e.type)) {
        var s2 = "PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";
        try {
          var c3 = e.type();
          E.lazyPropTypes.set(e.type, true), console.warn(s2 + "Component wrapped in lazy() is " + a(c3));
        } catch (n2) {
          console.warn(s2 + "We will log the wrapped component's name once it is loaded.");
        }
      }
      var l4 = e.props;
      e.type.__f && delete (l4 = function(n2, e2) {
        for (var t2 in e2) n2[t2] = e2[t2];
        return n2;
      }({}, l4)).ref, function(n2, e2, t2, r4, a2) {
        Object.keys(n2).forEach(function(t3) {
          var i3;
          try {
            i3 = n2[t3](e2, t3, r4, "prop", null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
          } catch (n3) {
            i3 = n3;
          }
          i3 && !(i3.message in o) && (o[i3.message] = true, console.error("Failed prop type: " + i3.message + (a2 && "\n" + a2() || "")));
        });
      }(e.type.propTypes, l4, 0, a(e), function() {
        return f(e);
      });
    }
    t && t(e);
  };
  var _, T = 0;
  l.__r = function(e) {
    l3 && l3(e), n = true;
    var t2 = e.__c;
    if (t2 === _ ? T++ : T = 1, T >= 25) throw new Error("Too many re-renders. This is limited to prevent an infinite loop which may lock up your browser. The component causing this is: " + a(e));
    _ = t2;
  }, l.__h = function(e, t2, o2) {
    if (!e || !n) throw new Error("Hook can only be invoked from render methods.");
    g && g(e, t2, o2);
  };
  var I = function(n2, e) {
    return { get: function() {
      var t2 = "get" + n2 + e;
      k2 && k2.indexOf(t2) < 0 && (k2.push(t2), console.warn("getting vnode." + n2 + " is deprecated, " + e));
    }, set: function() {
      var t2 = "set" + n2 + e;
      k2 && k2.indexOf(t2) < 0 && (k2.push(t2), console.warn("setting vnode." + n2 + " is not allowed, " + e));
    } };
  }, j = { nodeName: I("nodeName", "use vnode.type"), attributes: I("attributes", "use vnode.props"), children: I("children", "use vnode.props.children") }, O = Object.create({}, j);
  l.vnode = function(n2) {
    var e = n2.props;
    if (null !== n2.type && null != e && ("__source" in e || "__self" in e)) {
      var t2 = n2.props = {};
      for (var o2 in e) {
        var r3 = e[o2];
        "__source" === o2 ? n2.__source = r3 : "__self" === o2 ? n2.__self = r3 : t2[o2] = r3;
      }
    }
    n2.__proto__ = O, c2 && c2(n2);
  }, l.diffed = function(e) {
    var t2, o2 = e.type, i2 = e.__;
    if (e.__k && e.__k.forEach(function(n2) {
      if ("object" == typeof n2 && n2 && void 0 === n2.type) {
        var t3 = Object.keys(n2).join(",");
        throw new Error("Objects are not valid as a child. Encountered an object with the keys {" + t3 + "}.\n\n" + f(e));
      }
    }), e.__c === _ && (T = 0), "string" == typeof o2 && (y(o2) || "p" === o2 || "a" === o2 || "button" === o2)) {
      var s2 = h(i2);
      if ("" !== s2) "table" === o2 && "td" !== s2 && y(s2) ? (console.log(s2, i2.__e), console.error("Improper nesting of table. Your <table> should not have a table-node parent." + w(e) + "\n\n" + f(e))) : "thead" !== o2 && "tfoot" !== o2 && "tbody" !== o2 || "table" === s2 ? "tr" === o2 && "thead" !== s2 && "tfoot" !== s2 && "tbody" !== s2 ? console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot> parent." + w(e) + "\n\n" + f(e)) : "td" === o2 && "tr" !== s2 ? console.error("Improper nesting of table. Your <td> should have a <tr> parent." + w(e) + "\n\n" + f(e)) : "th" === o2 && "tr" !== s2 && console.error("Improper nesting of table. Your <th> should have a <tr>." + w(e) + "\n\n" + f(e)) : console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent." + w(e) + "\n\n" + f(e));
      else if ("p" === o2) {
        var c3 = d(e).filter(function(n2) {
          return m.test(n2);
        });
        c3.length && console.error("Improper nesting of paragraph. Your <p> should not have " + c3.join(", ") + "as child-elements." + w(e) + "\n\n" + f(e));
      } else "a" !== o2 && "button" !== o2 || -1 !== d(e).indexOf(o2) && console.error("Improper nesting of interactive content. Your <" + o2 + "> should not have other " + ("a" === o2 ? "anchor" : "button") + " tags as child-elements." + w(e) + "\n\n" + f(e));
    }
    if (n = false, r2 && r2(e), null != e.__k) for (var l4 = [], u2 = 0; u2 < e.__k.length; u2++) {
      var p2 = e.__k[u2];
      if (p2 && null != p2.key) {
        var v3 = p2.key;
        if (-1 !== l4.indexOf(v3)) {
          console.error('Following component has two or more children with the same key attribute: "' + v3 + '". This may cause glitches and misbehavior in rendering process. Component: \n\n' + w(e) + "\n\n" + f(e));
          break;
        }
        l4.push(v3);
      }
    }
    if (null != e.__c && null != e.__c.__H) {
      var b4 = e.__c.__H.__;
      if (b4) for (var g2 = 0; g2 < b4.length; g2 += 1) {
        var E2 = b4[g2];
        if (E2.__H) {
          for (var k3 = 0; k3 < E2.__H.length; k3++) if ((t2 = E2.__H[k3]) != t2) {
            var I2 = a(e);
            throw new Error("Invalid argument passed to hook. Hooks should not be called with NaN in the dependency array. Hook index " + g2 + " in component " + I2 + " was called with NaN.");
          }
        }
      }
    }
  };
}();
export {
  r as resetPropWarnings
};
//# sourceMappingURL=preact_debug.js.map
